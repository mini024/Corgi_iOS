%{

#import "DataBridge.h"
#define YYERROR_VERBOSE 1

int yylex(void);
void yyerror(char *s);

extern FILE *yyin;
extern int yylineno;
%}

%union
{
    float fval;
    int ival;
    char *strval;
    bool bval;
}

%locations
%error-verbose

// Tokens
%token <fval> FLOAT;
%token <ival> INT;
%token FOR;
%token BY;
%token IN;
%token ELSE;
%token WHILE;
%token <bval> BOOLEAN;
%token CASE_OR;
%token CORGI;
%token <strval> CORGIRUN;
%token CASE;
%token SLFT_BRA;
%token SRGT_BRA;
%token FOR_RANGE;
%token <strval> ID;
%token VAR;
%token LFT_PAR;
%token RGT_PAR;
%token SEMICOLON;
%token EQUAL;
%token COM_OP;
%token LOG_OP;
%token READ;
%token LFT_BRA;
%token RGT_BRA;
%token COLON;
%token <strval> STRING;
%token WRITE;
%token FUNC;
%token ARROW;
%token RETURN;
%token <strval> TYPE;
%token LOW_OP;
%token GRT_OP;
%token NOT_EQ;
%token LOW_EQ;
%token GRT_EQ;
%token EQ_EQ;
%token AND_OP;
%token OR_OP;
%token <strval> SUM;
%token <strval> SUBTRACTION;
%token <strval> PRODUCT;
%token <strval> DIVISION;
%token <strval> POW;
%token <strval> MOD;

%type <strval> tipo id

%%

program:
CORGI ID SEMICOLON {
    // Create Corgi program function
    if (!findFunctionBlock([NSString stringWithFormat:@"%s", $2])) {
        addCorgiFunctionBlock([NSString stringWithFormat:@"%s", $2], @"Corgi");
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of function \"%s\" \n", $2]);
    }
    
    // Create goTo -> CorgiRun Quadruple
    generateGOTOquadrupleBlock();
} vars functions corgirun { if (ParseTestSuccessBlock) ParseTestSuccessBlock(@"Success");}
;

functions:
function functions
| /*epsilon*/
;

function:
FUNC ID {
    // Create Function with id
    if (!findFunctionBlock([NSString stringWithFormat:@"%s", $2])) {
        addFunctionWithIdBlock([NSString stringWithFormat:@"%s", $2]);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of function \"%s\" \n", $2]);
    }
} LFT_PAR ID COLON tipo {
    // Store parameter
    if (!findParameterBlock([NSString stringWithFormat:@"%s", $5])) {
        addVariableBlock([NSString stringWithFormat:@"%s", $5],[NSString stringWithFormat:@"%s", $7], true);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of variable \"%s\" \n", $5]);
    }
} parameters RGT_PAR ARROW TYPE {
    // Add return type to function
    if (findFunctionBlock([NSString stringWithFormat:@"%s", $2])) {
        addFunctionReturnTypeBlock([NSString stringWithFormat:@"%s", $2],[NSString stringWithFormat:@"%s", $12]);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Function \"%s\" doesn't exist \n", $2]);
    }
} bloque {
    // EndFunc quadruple
    generateEndOfFunctionQuadrupleBlock();
}
;

parameters:
',' ID COLON tipo {
    // Store parameter
    if (!findParameterBlock([NSString stringWithFormat:@"%s", $2])) {
        addVariableBlock([NSString stringWithFormat:@"%s", $2],[NSString stringWithFormat:@"%s", $4], true);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of variable \"%s\" \n", $2]);
    }
} parameters
| /*epsilon*/
;

vars:
var vars
| /*epsilon*/
;

var:
VAR ID COLON tipo SEMICOLON {
    if (!findVariableBlock([NSString stringWithFormat:@"%s", $2])) {
        addVariableBlock([NSString stringWithFormat:@"%s", $2],[NSString stringWithFormat:@"%s", $4], false);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of variable \"%s\" \n", $2]);
    }
}
;

corgirun:
CORGIRUN LFT_PAR RGT_PAR {
    if (!findFunctionBlock([NSString stringWithFormat:@"%s", $1])) {
        addCorgiFunctionBlock([NSString stringWithFormat:@"%s", $1], @"corgiRun");
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of function \"%s\" \n", $1]);
    }
} LFT_BRA vars estatutos RGT_BRA {
    // End quadruple
    generateEndOfProgramQuadrupleBlock();
}
;

constante:
INT { addIdToStackBlock([NSString stringWithFormat:@"%d", $1], @"Int");}
| FLOAT { addIdToStackBlock([NSString stringWithFormat:@"%f", $1], @"Float");}
| id
| STRING { addIdToStackBlock([NSString stringWithFormat:@"%s", $1], @"String");}
| BOOLEAN { addIdToStackBlock([NSString stringWithFormat:@"%d", $1], @"Bool");}
;

bloque:
LFT_BRA vars estatutos return RGT_BRA
;

llamada:
ID {
    if (findFunctionBlock([NSString stringWithFormat:@"%s", $1])) {
        // Generate ERA with id
        generateERAQuadrupleBlock([NSString stringWithFormat:@"%s", $1]);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Wrong value type in parameter \"%s\"", $1]);
    }
} LFT_PAR Megaexpresion {
    // Send param/ save param quadruple
    if (!generateParameterQuadrupleBlock(@"parametro")) {
         ParseTestFailBlock([NSString stringWithFormat:@"Verify argument type \"%s\" doesn't exist \n", $1]);
    }
} llamadaParametros RGT_PAR SEMICOLON {
    //GoSub quadruple
    generateGoSubQuadrupleBlock(@"llamada");
}
;

llamadaParametros:
',' Megaexpresion llamadaParametros
| /*epsilon*/
;

estatutos:
estatuto estatutos
| /*epsilon*/
;

estatuto:
asignacion
| condicion
| loop
| write
| read
| llamada
;

id:
ID {
    if (findVariableBlock([NSString stringWithFormat:@"%s", $1])) {
        addIdToStackBlock([NSString stringWithFormat:@"%s", $1], @"Variable");
    } else if (findFunctionBlock([NSString stringWithFormat:@"%s", $1])) {
        // Generate ERA with id
        generateERAQuadrupleBlock([NSString stringWithFormat:@"%s", $1]);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Variable/Function with id \"%s\" doesn't exist \n", $1]);
    }
} idAux
;

idAux:
SLFT_BRA INT SRGT_BRA
| LFT_PAR Megaexpresion {
    // Send param/ save param quadruple
    generateParameterQuadrupleBlock(@"parametro");
} llamadaParametros RGT_PAR {
    //GoSub quadruple
    generateGoSubQuadrupleBlock(@"llamada");
}
| /*epsilon*/
;

asignacion:
id EQUAL {
    addOperatorToStackBlock(@"=");
} asignation SEMICOLON
;

asignation:
SLFT_BRA constante asignations SRGT_BRA
| Megaexpresion {
    if (!checkNextOperatorBlock(@"assignation"))
    ParseTestFailBlock([NSString stringWithFormat:@"Operation not valid, check data types \n"]);
}
;

asignations:
',' constante asignations
| /*epsilon*/
;

write:
WRITE LFT_PAR expresion {
    generateWritequadrupleBlock([NSString stringWithFormat:@"Hello\n"]);
} writeAux RGT_PAR SEMICOLON
;

writeAux:
',' expresion {
    generateWritequadrupleBlock([NSString stringWithFormat:@"Hello\n"]);
} writeAux
| /*epsilon*/
;

read:
READ LFT_PAR id RGT_PAR SEMICOLON
;

condicion:
CASE LFT_BRA expresion {
    generateGOTOFquadrupleBlock();
} COLON estatuto conditionAux RGT_BRA {
    fillEndConditionQuadrupleBlock();
}
;

conditionAux:
CASE_OR condicion2
| /*epsilon*/
;

condicion2:
expresion {
    generateGOTOFquadrupleBlock();
} COLON estatuto conditionAux
| conditionElse
;

conditionElse:
ELSE {
    generateGOTOquadrupleBlock();
} COLON estatuto {
    fillEndConditionQuadrupleBlock();
}
| /*epsilon*/
;

loop:
FOR ID {
    if (findVariableBlock([NSString stringWithFormat:@"%s", $2])) {
        addIdToStackBlock([NSString stringWithFormat:@"%s", $2], @"Variable");
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Variable with name \"%s\" doesn't exist \n", $2]);
    }
} IN INT {
    addIdToStackBlock([NSString stringWithFormat:@"%d", $5], @"Int");
} FOR_RANGE INT {
    addIdToStackBlock([NSString stringWithFormat:@"%d", $8], @"Int");
} BY INT {
    generateLoopConditionQuadruplesBlock([NSString stringWithFormat:@"%s", $2], $5, $8, $11);
    generateGOTOFquadrupleBlock();
    addIdToStackBlock([NSString stringWithFormat:@"%d", $11], @"Int");
} LFT_BRA estatutos {
    generateByQuadrupleBlock();
} RGT_BRA {
    generateGOTOquadrupleBlock();
    fillEndLoopQuadrupleBlock();
}
| WHILE LFT_PAR expresion RGT_PAR LFT_BRA estatutos RGT_BRA
;

return:
RETURN returnAux
;

returnAux:
Megaexpresion SEMICOLON
| SEMICOLON
;

Megaexpresion:
expresion {
    if (!checkNextOperatorBlock(@"logical"))
    ParseTestFailBlock([NSString stringWithFormat:@"Operation not valid, check data types \n"]);
} Superexpresion {
    if (!checkNextOperatorBlock(@"logical"))
    ParseTestFailBlock([NSString stringWithFormat:@"Operation not valid, check data types \n"]);
}
;

Superexpresion:
AND_OP {addOperatorToStackBlock(@"&&");} expresion
| OR_OP {addOperatorToStackBlock(@"||");} expresion
| /*epsilon*/
;

expresion:
exp {
    if (!checkNextOperatorBlock(@"relational"))
        ParseTestFailBlock([NSString stringWithFormat:@"Operation not valid, check data types \n"]);
} expresion2 {
    if (!checkNextOperatorBlock(@"relational"))
    ParseTestFailBlock([NSString stringWithFormat:@"Operation not valid, check data types \n"]);
}
;

expresion2:
LOW_OP {addOperatorToStackBlock(@"<");} exp 
| GRT_OP {addOperatorToStackBlock(@">");} exp
| NOT_EQ {addOperatorToStackBlock(@"!=");} exp
| LOW_EQ {addOperatorToStackBlock(@"<=");} exp
| GRT_EQ {addOperatorToStackBlock(@">=");} exp
| EQ_EQ {addOperatorToStackBlock(@"==");} exp
| /*epsilon*/
;

exp:
termino {
    if (!checkNextOperatorBlock(@"exp"))
        ParseTestFailBlock([NSString stringWithFormat:@"Operation not valid, check data types \n"]);
} exp2
;

exp2:
SUM { addOperatorToStackBlock(@"+"); } exp
| SUBTRACTION {addOperatorToStackBlock(@"-");} exp
| /*epsilon*/
;

termino:
factor {
    if (!checkNextOperatorBlock(@"term"))
        ParseTestFailBlock([NSString stringWithFormat:@"Operation not valid, check data types \n"]);
} termino2
;

termino2:
PRODUCT {addOperatorToStackBlock(@"*");} termino
| DIVISION {addOperatorToStackBlock(@"/");} termino
| POW {addOperatorToStackBlock(@"^");} termino
| MOD {addOperatorToStackBlock(@"%");} termino
| /*epsilon*/
;

factor:
LFT_PAR {addOperatorToStackBlock(@"(");} expresion RGT_PAR {deleteParentesisFromStackBlock();}
| SUM constante
| SUBTRACTION constante
| constante
;

tipo:
TYPE tipoAux {$$ = $1;}
;

tipoAux:
SLFT_BRA INT SRGT_BRA
| /*epsilon*/
;

%%

;
