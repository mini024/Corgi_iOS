%{

#import "DataBridge.h"
#define YYERROR_VERBOSE 1

int yylex(void);
void yyerror(char *s);

extern FILE *yyin;
extern int yylineno;
%}

%union
{
    float fval;
    int ival;
    char *strval;
    bool bval;
}

%locations
%error-verbose

// Tokens
%token <fval> FLOAT;
%token <ival> INT;
%token FOR;
%token BY;
%token IN;
%token ELSE;
%token WHILE;
%token <bval> BOOLEAN;
%token CASE_OR;
%token CORGI;
%token <strval> CORGIRUN;
%token CASE;
%token SLFT_BRA;
%token SRGT_BRA;
%token FOR_RANGE;
%token <strval> ID;
%token VAR;
%token LFT_PAR;
%token RGT_PAR;
%token SEMICOLON;
%token EQUAL;
%token COM_OP;
%token LOG_OP;
%token READ;
%token LFT_BRA;
%token RGT_BRA;
%token COLON;
%token <strval> STRING;
%token WRITE;
%token FUNC;
%token ARROW;
%token RETURN;
%token <strval> TYPE;
%token LOW_OP;
%token GRT_OP;
%token NOT_EQ;
%token LOW_EQ;
%token GRT_EQ;
%token EQ_EQ;
%token AND_OP;
%token OR_OP;
%token <strval> SUM;
%token <strval> SUBTRACTION;
%token <strval> PRODUCT;
%token <strval> DIVISION;
%token <strval> POW;
%token <strval> MOD;

%type <strval> tipo id

%%

program:
CORGI ID SEMICOLON {
    if (!findFunctionBlock([NSString stringWithFormat:@"%s", $2])) {
        addFunctionBlock([NSString stringWithFormat:@"%s", $2],@"Corgi");
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of function \"%s\" \n", $2]);
    }
} vars functions corgirun { if (ParseTestSuccessBlock) ParseTestSuccessBlock(@"Success");}
;

functions:
function functions
| /*epsilon*/
;

function:
FUNC ID LFT_PAR ID COLON tipo parameters RGT_PAR ARROW TYPE {
    if (!findFunctionBlock([NSString stringWithFormat:@"%s", $2])) {
        addFunctionBlock([NSString stringWithFormat:@"%s", $2],[NSString stringWithFormat:@"%s", $10]);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of function \"%s\" \n", $2]);
    }
} bloque
;

parameters:
',' ID COLON tipo parameters
| /*epsilon*/
;

vars:
var vars
| /*epsilon*/
;

var:
VAR ID COLON tipo SEMICOLON {
    if (!findVariableBlock([NSString stringWithFormat:@"%s", $2])) {
        addVariableBlock([NSString stringWithFormat:@"%s", $2],[NSString stringWithFormat:@"%s", $4]);
    } else {
        ParseTestFailBlock([NSString stringWithFormat:@"Redeclaration of variable \"%s\" \n", $2]);
    }
}
;

corgirun:
CORGIRUN LFT_PAR RGT_PAR {addFunctionBlock([NSString stringWithFormat:@"%s", $1],@"corgiRun");} LFT_BRA vars estatutos RGT_BRA
;

constante:
INT { addIdToStackBlock([NSString stringWithFormat:@"%d", $1], @"Int");}
| FLOAT { addIdToStackBlock([NSString stringWithFormat:@"%f", $1], @"Float");}
| id
| STRING { addIdToStackBlock([NSString stringWithFormat:@"%s", $1], @"String");}
| BOOLEAN { addIdToStackBlock([NSString stringWithFormat:@"%d", $1], @"Bool");}
;

bloque:
LFT_BRA vars estatutos return RGT_BRA
;

estatutos:
estatuto estatutos
| /*epsilon*/
;

estatuto:
asignacion
| condicion
| loop
| write
| read
;

id:
ID index
;

index:
SLFT_BRA INT SRGT_BRA
| /*epsilon*/
;

asignacion:
id EQUAL asignation SEMICOLON
;

asignation:
SLFT_BRA constante asignations SRGT_BRA
| expresion;
;

asignations:
',' constante asignations
| /*epsilon*/
;

write:
WRITE LFT_PAR expresion writeAux RGT_PAR SEMICOLON
;

writeAux:
',' expresion writeAux
| /*epsilon*/
;

read:
READ LFT_PAR id RGT_PAR SEMICOLON
;

condicion:
CASE LFT_BRA expresion COLON estatuto conditionAux RGT_BRA
;

conditionAux:
CASE_OR condicion2
| /*epsilon*/
;

condicion2:
expresion COLON estatuto conditionAux
| conditionElse

conditionElse:
ELSE COLON estatuto
| /*epsilon*/
;

loop:
FOR ID IN INT FOR_RANGE INT BY INT LFT_BRA estatutos RGT_BRA
| WHILE LFT_PAR expresion RGT_PAR LFT_BRA estatutos RGT_BRA
;

return:
RETURN exp SEMICOLON
;

Megaexpresion:
expresion Superexpresion
;

Superexpresion:
AND_OP expresion
| OR_OP expresion
| /*epsilon*/
;

expresion:
exp {checkNextOperatorBlock(@"relational");} expresion2
;

expresion2:
LOW_OP {addOperatorToStackBlock(@"<");} exp
| GRT_OP {addOperatorToStackBlock(@">");} exp
| NOT_EQ {addOperatorToStackBlock(@"!=");} exp
| LOW_EQ {addOperatorToStackBlock(@"<=");} exp
| GRT_EQ {addOperatorToStackBlock(@">=");} exp
| EQ_EQ {addOperatorToStackBlock(@"==");} exp
| /*epsilon*/
;

exp:
termino {checkNextOperatorBlock(@"exp");} exp2
;

exp2:
SUM {addOperatorToStackBlock(@"+");} exp
| SUBTRACTION {addOperatorToStackBlock(@"-");} exp
| /*epsilon*/
;

termino:
factor {checkNextOperatorBlock(@"term");} termino2
;

termino2:
PRODUCT {addOperatorToStackBlock(@"*");} termino
| DIVISION {addOperatorToStackBlock(@"/");} termino
| POW {addOperatorToStackBlock(@"^");} termino
| MOD {addOperatorToStackBlock(@"%");} termino
| /*epsilon*/
;

factor:
LFT_PAR {addOperatorToStackBlock(@"(");} expresion RGT_PAR {deleteParentesisFromStackBlock();}
| SUM constante
| SUBTRACTION constante
| constante
;

tipo:
TYPE tipoAux {$$ = $1;}
;

tipoAux:
SLFT_BRA INT SRGT_BRA
| /*epsilon*/
;

%%

;
